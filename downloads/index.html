<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>H#</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="icon" href="https://iamapersson.github.io/hsharp/hsharplogo.png">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">H#</h1>
      <h2 class="project-tagline">A place to learn about and download the H# interpreter.</h2>
      <a href="https://iamapersson.github.io/hsharp" class="btn">Home</a>
    </section>

    <section class="main-content">
      <h1>
<a id="hsharp" class="anchor" href="#hsharp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Downloads</h1>

<p>Are you ready to download H#? Click one of the links below to grab your copy!</p>
<a href="https://github.com/IAmAPersson/hsharp">View on GitHub</a><br>
      <a href="https://github.com/IAmAPersson/hsharp/zipball/master">Download .zip</a>
    </section>

  // Generated by JSIL v0.8.2 build 13182. See http://jsil.org/ for more information. 

'use strict';
var $asm00 = JSIL.GetAssembly("7e17e1ad, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null");
var $asm01 = JSIL.GetAssembly("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
var $asm02 = JSIL.GetAssembly("System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");

/* Generated by JSIL v0.8.2 build 13182. See http://jsil.org/ for more information. */ 
'use strict';
var $asm00 = JSIL.DeclareAssembly("7e17e1ad, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null");

JSIL.SetEntryPoint($asm00, $asm00.TypeRef("HSCi.MainLoop"), "Main", JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm01.TypeRef("System.String")])));

JSIL.DeclareNamespace("HSCi");
/* class HSCi.Parser */ 

(function Parser$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm01.System.Collections.Generic.Dictionary$b2.Of($asm01.System.String, $asm01.System.String))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm01.System.Int32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm01.System.Convert)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm01.System.String)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm01.System.Double)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm01.System.Console)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm01.System.Math)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm01.System.Collections.Generic.List$b1.Of($asm01.System.String))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm01.System.Char)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm01.System.Exception)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm00.HSCi.Parser_$lfilt$gc__AnonStorey1)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize(System.Array.Of($asm01.System.String))) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm02.System.Linq.Enumerable)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm01.System.Func$b2.Of($asm01.System.String, $asm01.System.Boolean))) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize(System.Array.Of($asm01.System.Int32))) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize($asm01.System.Boolean)) ();
  };
  var $T10 = function () {
    return ($T10 = JSIL.Memoize($asm01.System.Collections.Generic.List$b1.Of($asm01.System.Char))) ();
  };
  var $T11 = function () {
    return ($T11 = JSIL.Memoize($asm01.System.Collections.Generic.IEnumerable$b1.Of($asm01.System.Char))) ();
  };
  var $T12 = function () {
    return ($T12 = JSIL.Memoize($asm00.HSCi.Parser_$lmapf$gc__AnonStorey0)) ();
  };
  var $T13 = function () {
    return ($T13 = JSIL.Memoize($asm01.System.Func$b2.Of($asm01.System.String, $asm01.System.String))) ();
  };
  var $T14 = function () {
    return ($T14 = JSIL.Memoize($asm01.System.Tuple$b2.Of($asm01.System.Boolean, $asm01.System.Collections.Generic.Dictionary$b2.Of($asm01.System.String, $asm01.System.String)))) ();
  };
  var $T15 = function () {
    return ($T15 = JSIL.Memoize($asm01.System.Collections.Generic.IEnumerator$b1.Of($asm01.System.String))) ();
  };
  var $T16 = function () {
    return ($T16 = JSIL.Memoize($asm01.System.Collections.Generic.IEnumerable$b1.Of($asm01.System.String))) ();
  };
  var $T17 = function () {
    return ($T17 = JSIL.Memoize($asm01.System.Collections.IEnumerator)) ();
  };
  var $T18 = function () {
    return ($T18 = JSIL.Memoize($asm01.System.Collections.Generic.Dictionary$b2_KeyCollection_Enumerator.Of($asm01.System.String, $asm01.System.String))) ();
  };
  var $T19 = function () {
    return ($T19 = JSIL.Memoize($asm01.System.Collections.Generic.Dictionary$b2_KeyCollection.Of($asm01.System.String, $asm01.System.String))) ();
  };
  var $T1A = function () {
    return ($T1A = JSIL.Memoize($asm01.System.IDisposable)) ();
  };
  var $T1B = function () {
    return ($T1B = JSIL.Memoize($asm01.System.Collections.Generic.IEnumerable$b1.Of($asm01.System.Int32))) ();
  };
  var $T1C = function () {
    return ($T1C = JSIL.Memoize($asm01.System.Func$b2.Of($asm01.System.Int32, $asm01.System.String))) ();
  };
  var $T1D = function () {
    return ($T1D = JSIL.Memoize($asm01.System.Collections.IEnumerable)) ();
  };
  var $T1E = function () {
    return ($T1E = JSIL.Memoize($asm01.System.StackOverflowException)) ();
  };
  var $T1F = function () {
    return ($T1F = JSIL.Memoize($asm01.System.Collections.Generic.List$b1.Of($asm01.System.Int32))) ();
  };
  var $T20 = function () {
    return ($T20 = JSIL.Memoize($asm01.System.Collections.Generic.Dictionary$b2.Of($asm01.System.String, $asm01.System.Int32))) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm01.TypeRef("System.Collections.Generic.Dictionary`2", [$asm01.TypeRef("System.String"), $asm01.TypeRef("System.String")]), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.String"), [$asm01.TypeRef("System.Int32")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.String"), [$asm01.TypeRef("System.Double")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm01.TypeRef("System.Collections.Generic.List`1", [$asm01.TypeRef("System.String")]), null))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"]), [$asm01.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"]), $asm01.TypeRef("System.Func`2", ["!!0", $asm01.TypeRef("System.Boolean")])], ["TSource"]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.Boolean"), [$asm01.TypeRef("System.Char")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.Double"), [$asm01.TypeRef("System.String")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature("!!0", [$asm01.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"])], ["TSource"]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!1"]), [$asm01.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"]), $asm01.TypeRef("System.Func`2", ["!!0", "!!1"])], ["TSource", "TResult"]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!1"]), [$asm01.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"]), $asm01.TypeRef("System.Func`2", ["!!0", "!!1"])], ["TSource", "TResult"]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.Int32"), [$asm01.TypeRef("System.String")]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.String"), [$asm01.TypeRef("System.Int32")]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature("!!0", [$asm01.TypeRef("System.Collections.Generic.IEnumerable`1", ["!!0"])], ["TSource"]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.ConstructorSignature($asm01.TypeRef("System.Collections.Generic.List`1", [$asm01.TypeRef("System.Char")]), null))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.Char"), [$asm01.TypeRef("System.Int32")]))) ();
  };
  var $S0F = function () {
    return ($S0F = JSIL.Memoize(new JSIL.ConstructorSignature($asm01.TypeRef("System.StackOverflowException"), null))) ();
  };
  var $S10 = function () {
    return ($S10 = JSIL.Memoize(new JSIL.ConstructorSignature($asm01.TypeRef("System.Collections.Generic.List`1", [$asm01.TypeRef("System.Int32")]), null))) ();
  };
  var $S11 = function () {
    return ($S11 = JSIL.Memoize(new JSIL.ConstructorSignature($asm01.TypeRef("System.Collections.Generic.Dictionary`2", [$asm01.TypeRef("System.String"), $asm01.TypeRef("System.Int32")]), [$asm01.TypeRef("System.Int32")]))) ();
  };
  var $IM00 = function () {
    return ($IM00 = JSIL.Memoize($asm01.System.Collections.Generic.IEnumerable$b1.Of($asm01.System.String).GetEnumerator)) ();
  };
  var $IM01 = function () {
    return ($IM01 = JSIL.Memoize($asm01.System.Collections.IEnumerator.MoveNext)) ();
  };
  var $IM02 = function () {
    return ($IM02 = JSIL.Memoize($asm01.System.Collections.Generic.IEnumerator$b1.Of($asm01.System.String).get_Current)) ();
  };
  var $IM03 = function () {
    return ($IM03 = JSIL.Memoize($asm01.System.IDisposable.Dispose)) ();
  };

  function Parser_$lparseMath$gm__0 (x) {
    return $S01().CallStatic($T02(), "ToString", null, x);
  };

  function Parser_$lparseMath$gm__1 (x) {
    return $S01().CallStatic($T02(), "ToString", null, x);
  };

  function Parser_$lparseMath$gm__2 (x) {
    return $thisType.parseMath(x);
  };

  function Parser_acos (s) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot take arccosine of nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else {
      num.set((Math.acos(num.get())));
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  function Parser_asin (s) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot take arcsine of nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else {
      num.set((Math.asin(num.get())));
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  function Parser_atan (s) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot take arctangent of nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else {
      num.set((Math.atan(num.get())));
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  function Parser_betwbraces (s) {
    var inparen = 0;
    var text = "";
    var arr = $S03().Construct();

    for (var j = 0; j < (s.length | 0); j = ((j + 1) | 0)) {
      var i = (s[j]);
      if (!(((i.charCodeAt(0) | 0) !== (("}").charCodeAt(0) | 0)) || (inparen !== 1))) {
        arr.Add(text);
        inparen = 0;
        text = "";
      } else if ((i.charCodeAt(0) | 0) === (("}").charCodeAt(0) | 0)) {
        inparen = ((inparen - 1) | 0);
      }
      if (inparen > 0) {
        text = (JSIL.ConcatString(text, i));
      }
      if ((i.charCodeAt(0) | 0) === (("{").charCodeAt(0) | 0)) {
        inparen = ((inparen + 1) | 0);
      }
    }
    return $T07().prototype.ToArray.call(arr);
  };

  function Parser_betwbracks (s) {
    var inparen = 0;
    var text = "";
    var arr = $S03().Construct();

    for (var j = 0; j < (s.length | 0); j = ((j + 1) | 0)) {
      var i = (s[j]);
      if (!(((i.charCodeAt(0) | 0) !== (("]").charCodeAt(0) | 0)) || (inparen !== 1))) {
        arr.Add(text);
        inparen = 0;
        text = "";
      } else if ((i.charCodeAt(0) | 0) === (("]").charCodeAt(0) | 0)) {
        inparen = ((inparen - 1) | 0);
      }
      if (inparen > 0) {
        text = (JSIL.ConcatString(text, i));
      }
      if ((i.charCodeAt(0) | 0) === (("[").charCodeAt(0) | 0)) {
        inparen = ((inparen + 1) | 0);
      }
    }
    return $T07().prototype.ToArray.call(arr);
  };

  function Parser_betwparen (s) {
    var inparen = 0;
    var text = "";
    var arr = $S03().Construct();

    for (var j = 0; j < (s.length | 0); j = ((j + 1) | 0)) {
      var i = (s[j]);
      if (!(((i.charCodeAt(0) | 0) !== ((")").charCodeAt(0) | 0)) || (inparen !== 1))) {
        arr.Add(text);
        inparen = 0;
        text = "";
      } else if ((i.charCodeAt(0) | 0) === ((")").charCodeAt(0) | 0)) {
        inparen = ((inparen - 1) | 0);
      }
      if (inparen > 0) {
        text = (JSIL.ConcatString(text, i));
      }
      if ((i.charCodeAt(0) | 0) === (("(").charCodeAt(0) | 0)) {
        inparen = ((inparen + 1) | 0);
      }
    }
    return $T07().prototype.ToArray.call(arr);
  };

  function Parser_ceil (s) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot ceiling a nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else {
      num.set((Math.ceil(num.get())));
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  function Parser_cosi (s) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot take cosine of nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else {
      num.set((Math.cos(num.get())));
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  function Parser_EffPrep (s, $exception) {
    s = (JSIL.ConcatString(" ", s));

    for (var i = 0; i < (s.length | 0); i = ((i + 1) | 0)) {
      try {
        if (!(!(s.substr(i, 3) == "sin") || 
            !$thisType.IsntSurrounded(s, i, 3) || $thisType.wildcards.ContainsKey("sin[X]"))) {
          $thisType.wildcards.Add("sin[X]", "internalcmmdsineX");
        } else if (!(!(s.substr(i, 3) == "cos") || 
            !$thisType.IsntSurrounded(s, i, 3) || $thisType.wildcards.ContainsKey("cos[X]"))) {
          $thisType.wildcards.Add("cos[X]", "internalcmmdcosiX");
        } else if (!(!(s.substr(i, 3) == "tan") || 
            !$thisType.IsntSurrounded(s, i, 3) || $thisType.wildcards.ContainsKey("tan[X]"))) {
          $thisType.wildcards.Add("tan[X]", "internalcmmdtangX");
        } else if (!(!(s.substr(i, 4) == "asin") || 
            !$thisType.IsntSurrounded(s, i, 4) || $thisType.wildcards.ContainsKey("asin[X]"))) {
          $thisType.wildcards.Add("asin[X]", "internalcmmdasinX");
        } else if (!(!(s.substr(i, 4) == "acos") || 
            !$thisType.IsntSurrounded(s, i, 4) || $thisType.wildcards.ContainsKey("acos[X]"))) {
          $thisType.wildcards.Add("acos[X]", "internalcmmdacosX");
        } else if (!(!(s.substr(i, 4) == "atan") || 
            !$thisType.IsntSurrounded(s, i, 4) || $thisType.wildcards.ContainsKey("atan[X]"))) {
          $thisType.wildcards.Add("atan[X]", "internalcmmdatanX");
        } else if (!(!(s.substr(i, 5) == "print") || 
            !$thisType.IsntSurrounded(s, i, 5) || $thisType.wildcards.ContainsKey("print[X]"))) {
          $thisType.wildcards.Add("print[X]", "internalcmmdprntX");
        } else if (!(!(s.substr(i, 5) == "floor") || 
            !$thisType.IsntSurrounded(s, i, 5) || $thisType.wildcards.ContainsKey("floor[X]"))) {
          $thisType.wildcards.Add("floor[X]", "internalcmmdflorX");
        } else if (!(!(s.substr(i, 7) == "ceiling") || 
            !$thisType.IsntSurrounded(s, i, 7) || $thisType.wildcards.ContainsKey("ceiling[X]"))) {
          $thisType.wildcards.Add("ceiling[X]", "internalcmmdceilX");
        } else if (!(!(s.substr(i, 3) == "map") || 
            !$thisType.IsntSurrounded(s, i, 3) || $thisType.wildcards.ContainsKey("map[F,L]"))) {
          $thisType.wildcards.Add("map[F,L]", "internalcmmdmapfF,L");
        } else if (!(!(s.substr(i, 5) == "round") || 
            !$thisType.IsntSurrounded(s, i, 5) || $thisType.wildcards.ContainsKey("round[X]"))) {
          $thisType.wildcards.Add("round[X]", "internalcmmdrondX");
        } else if (!(!(s.substr(i, 3) == "max") || 
            !$thisType.IsntSurrounded(s, i, 3) || $thisType.wildcards.ContainsKey("max[A,B]"))) {
          $thisType.wildcards.Add("max[A,B]", "_if_A>B_then_A_else_B");
        } else if (!(!(s.substr(i, 3) == "min") || 
            !$thisType.IsntSurrounded(s, i, 3) || $thisType.wildcards.ContainsKey("min[A,B]"))) {
          $thisType.wildcards.Add("min[A,B]", "_if_A<B_then_A_else_B");
        } else if (!(!(s.substr(i, 3) == "abs") || 
            !$thisType.IsntSurrounded(s, i, 3) || $thisType.wildcards.ContainsKey("abs[X]"))) {
          $thisType.wildcards.Add("abs[X]", "_if_X<0_then_-(X)_else_X");
        } else if (!(!(s.substr(i, 2) == "ln") || 
            !$thisType.IsntSurrounded(s, i, 2) || $thisType.wildcards.ContainsKey("ln[X]"))) {
          $thisType.wildcards.Add("ln[X]", "internalcmmdnlogX,e");
        } else if (!(!(s.substr(i, 3) == "log") || 
            !$thisType.IsntSurrounded(s, i, 3) || $thisType.wildcards.ContainsKey("log[X]"))) {
          $thisType.wildcards.Add("log[X]", "internalcmmdnlogX,10");
          $thisType.wildcards.Add("log[X,Y]", "internalcmmdnlogX,Y");
        } else if (!(!(s.substr(i, 4) == "sign") || 
            !$thisType.IsntSurrounded(s, i, 4) || $thisType.wildcards.ContainsKey("sign[X]"))) {
          $thisType.wildcards.Add("sign[X]", "_if_X=0_then_0_else__if_X>0_then_1_else_-1");
        } else if (!(!(s.substr(i, 4) == "sqrt") || 
            !$thisType.IsntSurrounded(s, i, 4) || $thisType.wildcards.ContainsKey("sqrt[X]"))) {
          $thisType.wildcards.Add("sqrt[X]", "X^0.5");
        } else if (!(!(s.substr(i, 4) == "cbrt") || 
            !$thisType.IsntSurrounded(s, i, 4) || $thisType.wildcards.ContainsKey("cbrt[X]"))) {
          $thisType.wildcards.Add("cbrt[X]", "X^(1/3)");
        } else if (!(!(s.substr(i, 3) == "nrt") || 
            !$thisType.IsntSurrounded(s, i, 3) || $thisType.wildcards.ContainsKey("nrt[X,N]"))) {
          $thisType.wildcards.Add("nrt[X,N]", "X^(1/N)");
        } else if (!(!(s.substr(i, 8) == "truncate") || 
            !$thisType.IsntSurrounded(s, i, 8) || $thisType.wildcards.ContainsKey("truncate[X]"))) {
          $thisType.wildcards.Add("truncate[X]", "internalcmmdtrunX");
        } else if (!(!(s.substr(i, 10) == "reciprocal") || 
            !$thisType.IsntSurrounded(s, i, 10) || $thisType.wildcards.ContainsKey("reciprocal[X]"))) {
          $thisType.wildcards.Add("reciprocal[X]", "1/X");
        } else if (!(!(s.substr(i, 6) == "filter") || 
            !$thisType.IsntSurrounded(s, i, 6) || $thisType.wildcards.ContainsKey("filter[F,L]"))) {
          $thisType.wildcards.Add("filter[F,L]", "internalcmmdfiltF,L");
        }
      } catch ($exception) {
      }
    }
  };

  function Parser_filt (f, l) {
    var $lfilt$gc__AnonStorey = new ($T0A())();
    $lfilt$gc__AnonStorey.f = f;
    var res = "[";
    if ($thisType.vars.ContainsKey(l)) {
      l = $thisType.parseMath($thisType.vars.get_Item(l));
    }
    if ($thisType.vars.ContainsKey($lfilt$gc__AnonStorey.f)) {
      $lfilt$gc__AnonStorey.f = $thisType.parseMath($thisType.vars.get_Item($lfilt$gc__AnonStorey.f));
    }
    if (!$thisType.isarray(l)) {
      $T05().WriteLine("Error: Cannot map function to non-list value. Aborting operation.");
      var result = "";
    } else {
      var num = $T0C().ToArray$b1($T03())($S04().CallStatic($T0C(), "Where$b1", [$asm01.System.String], 
          $thisType.listsplit($thisType.betwbracks(l)[0], ","), 
          $T0D().New($lfilt$gc__AnonStorey, $T0A().prototype.$l$gm__0, function () { return JSIL.GetMethodInfo($asm00.HSCi.Parser_$lfilt$gc__AnonStorey1, "$l$gm__0", new JSIL.MethodSignature($asm01.System.Boolean, [$asm01.System.String]), false); })
        ));
      var array = num;

      for (var j = 0; j < (array.length | 0); j = ((j + 1) | 0)) {
        var i = array[j];
        res = ((res + i + ","));
      }
      res = (res.substr(0, (((res.length | 0) - 1) | 0)));
      res = (JSIL.ConcatString(res, "]"));
      result = res;
    }
    return result;
  };

  function Parser_fixneg (s, $exception) {
    var text = s;

    for (var l = 0; l < (text.length | 0); l = ((l + 1) | 0)) {
      var i = (text[l]);
      if ((i.charCodeAt(0) | 0) === (("`").charCodeAt(0) | 0)) {
        if (!(((s.length | 0) <= 0) || (((s[0]).charCodeAt(0) | 0) !== (("`").charCodeAt(0) | 0)))) {
          s = (JSIL.ConcatString("-", s.substr(1)));
        }
        var result = s;
        return result;
      }
    }
    var res = "";
    var array = $thisType.range(0, s.length, 1);

    for (var m = 0; m < (array.length | 0); m = ((m + 1) | 0)) {
      var j = (array[m] | 0);
      try {
        if (!((((s[j]).charCodeAt(0) | 0) !== (("-").charCodeAt(0) | 0)) || ((((s[((j - 1) | 0)]).charCodeAt(0) | 0) >= (("0").charCodeAt(0) | 0)) && 
              (((s[((j - 1) | 0)]).charCodeAt(0) | 0) <= (("9").charCodeAt(0) | 0))))) {
          res = (JSIL.ConcatString(res, "`"));
        } else {
          res = (JSIL.ConcatString(res, s[j]));
        }
      } catch ($exception) {
        if (((s[0]).charCodeAt(0) | 0) === (("-").charCodeAt(0) | 0)) {
          res = (JSIL.ConcatString(res, "`"));
        }
      }
    }
    s = res;
    res = "";
    var array2 = $thisType.range(0, s.length, 1);

    for (var n = 0; n < (array2.length | 0); n = ((n + 1) | 0)) {
      var k = (array2[n] | 0);
      if (((s[k]).charCodeAt(0) | 0) === (("-").charCodeAt(0) | 0)) {
        res = (JSIL.ConcatString(res, "`"));
      } else if (((s[k]).charCodeAt(0) | 0) === (("`").charCodeAt(0) | 0)) {
        res = (JSIL.ConcatString(res, "-"));
      } else {
        res = (JSIL.ConcatString(res, s[k]));
      }
    }
    if (!(((res.length | 0) <= 0) || (((res[0]).charCodeAt(0) | 0) !== (("`").charCodeAt(0) | 0)))) {
      res = (JSIL.ConcatString("-", res.substr(1)));
    }
    result = res;
    return result;
  };

  function Parser_flor (s) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot floor a nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else {
      num.set((Math.floor(num.get())));
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  function Parser_forget (s) {
    var varname = $thisType.fixneg($thisType.remspaces($thisType.split(s.substr(5), "=")[0]));
    var haswildcard = false;
    var i = 0;

    while ($S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), "(") && !$S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), ")")) {
      varname = ((varname + "=" + $thisType.remspaces($thisType.split(s.substr(5), "=")[(i = ((i + 1) | 0))])));
    }
    if ($S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), "(")) {
      varname = $thisType.betwparen(varname)[0];
    }
    if (!((($thisType.split(s, "_if_").length | 0) !== 2) || (($thisType.split(s, "_then_").length | 0) !== 1))) {
      var res = $thisType.ParseMath($thisType.split(s, "_if_")[1]);
      if (res == "false") {
        var result = true;
        return result;
      }
      if (!(res == "true")) {
        result = true;
        return result;
      }
      var text = varname;

    $loop2: 
      for (var l = 0; l < (text.length | 0); l = ((l + 1) | 0)) {
        var j = (text[l]);
        if (!(((j.charCodeAt(0) | 0) < (("A").charCodeAt(0) | 0)) || ((j.charCodeAt(0) | 0) > (("Z").charCodeAt(0) | 0)))) {
          haswildcard = true;
          break $loop2;
        }
      }
      if (!haswildcard) {
        $thisType.vars.Remove(varname);
      } else {
        $thisType.wildcards.Remove(varname);
      }
    } else {
      var text2 = varname;

    $loop1: 
      for (var m = 0; m < (text2.length | 0); m = ((m + 1) | 0)) {
        var k = (text2[m]);
        if (!(((k.charCodeAt(0) | 0) < (("A").charCodeAt(0) | 0)) || ((k.charCodeAt(0) | 0) > (("Z").charCodeAt(0) | 0)))) {
          haswildcard = true;
          break $loop1;
        }
      }
      if (!haswildcard) {
        $thisType.vars.Remove(varname);
      } else {
        $thisType.wildcards.Remove(varname);
      }
    }
    result = true;
    return result;
  };

  function Parser_gama (s, $exception) {
    var alpha = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ alpha)) {
      $T05().WriteLine("Error: Cannot take factorial of nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else if (+alpha.get() <= 0) {
      $T05().WriteLine("Error: Cannot take factorial of negative value. Aborting operation.");
      result = "";
    } else {
      try {
        var gamma = 0;
        if (+alpha.get() > 0) {
          if (!((+alpha.get() <= 0) || (+alpha.get() >= 1))) {
            gamma = +((+$S06().CallStatic($T02(), "ToDouble", null, $thisType.gama($S02().CallStatic($T02(), "ToString", null, +alpha.get() + 1))) / +alpha.get()));
          } else if (!((+alpha.get() < 1) || (+alpha.get() > 2))) {
            gamma = (((((((1 - (0.577191652 * (Math.pow((+alpha.get() - 1), 1)))) + (0.988205891 * (Math.pow((+alpha.get() - 1), 2)))) - (0.897056937 * (Math.pow((+alpha.get() - 1), 3)))) + (0.918206857 * (Math.pow((+alpha.get() - 1), 4)))) - (0.756704078 * (Math.pow((+alpha.get() - 1), 5)))) + (0.482199394 * (Math.pow((+alpha.get() - 1), 6)))) - (0.193527818 * (Math.pow((+alpha.get() - 1), 7)))) + (0.03586843 * (Math.pow((+alpha.get() - 1), 8)));
          } else {
            gamma = (+alpha.get() - 1) * +$S06().CallStatic($T02(), "ToDouble", null, $thisType.gama($S02().CallStatic($T02(), "ToString", null, +alpha.get() - 1)));
          }
        }
        if (+alpha.get() > 171) {
          gamma = (Math.pow(10, 307));
        }
        result = $S02().CallStatic($T02(), "ToString", null, gamma);
      } catch ($exception) {
        throw $exception;
      }
    }
    return result;
  };

  function Parser_getl (s, base_) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if ($thisType.vars.ContainsKey(base_)) {
      base_ = $thisType.parseMath($thisType.vars.get_Item(base_));
    }
    if (!$T01().TryParse(base_, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot get list element with noninteger index value (includes booleans, unknown variables, decimals, or infinity). Aborting operation.");
      var result = "";
    } else {
      var num2 = $thisType.listsplit($thisType.betwbracks(s)[0], ",");
      result = $thisType.remspaces(num2[(((num.get() | 0) % (num2.length | 0)) | 0)]);
    }
    return result;
  };

  function Parser_isarray (s) {
    if (!(!(s.substr(0, 1) == "[") || ((($S07().CallStatic($T0C(), "Last$b1", [$asm01.System.Char], $T0C().ToList$b1($T08())($T11().$Cast(JSIL.StringToCharArray(s))))).charCodeAt(0) | 0) !== (("]").charCodeAt(0) | 0)))) {
      var array = $thisType.split($thisType.betwbracks(s)[0], ",");

      for (var i = 0; i < (array.length | 0); i = ((i + 1) | 0)) {
        var ret = array[i];
        if (!((ret == "true") || 
            (ret == "false") || 
            (ret == "unknown") || 
            (ret == "infinity") || ($S02().CallStatic($T02(), "ToString", null, $S06().CallStatic($T02(), "ToDouble", null, ret)) == ret))) {
          var result = false;
          return result;
        }
      }
      result = true;
    } else {
      result = false;
    }
    return result;
  };

  function Parser_IsntSurrounded (s, i, length) {
    return (!(((((s.substr((((i | 0) - 1) | 0))[0]).charCodeAt(0) | 0) >= (("A").charCodeAt(0) | 0)) && 
          (((s.substr((((i | 0) - 1) | 0))[0]).charCodeAt(0) | 0) <= (("Z").charCodeAt(0) | 0))) || 
        ((((s.substr((((i | 0) - 1) | 0))[0]).charCodeAt(0) | 0) >= (("a").charCodeAt(0) | 0)) && 
          (((s.substr((((i | 0) - 1) | 0))[0]).charCodeAt(0) | 0) <= (("z").charCodeAt(0) | 0))) || 
        ((((s.substr((((i | 0) + (length | 0)) | 0))[0]).charCodeAt(0) | 0) >= (("A").charCodeAt(0) | 0)) && 
          (((s.substr((((i | 0) + (length | 0)) | 0))[0]).charCodeAt(0) | 0) <= (("Z").charCodeAt(0) | 0)))) && !((((s.substr((((i | 0) + (length | 0)) | 0))[0]).charCodeAt(0) | 0) >= (("a").charCodeAt(0) | 0)) && 
        (((s.substr((((i | 0) + (length | 0)) | 0))[0]).charCodeAt(0) | 0) <= (("z").charCodeAt(0) | 0))));
  };

  function Parser_let (s, suppressdup) {
    var trash = new JSIL.BoxedVariable(0);
    var varname = $thisType.fixneg($thisType.remspaces($thisType.split(s.substr(5), "=")[0]));
    var valname = $thisType.remstartspaces($thisType.singlesplit(s.substr(5), "=")[1]);
    var haswildcard = false;
    var i = 0;

    while ($S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), "(") && !$S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), ")")) {
      varname = ((varname + "=" + $thisType.remspaces($thisType.split(s.substr(5), "=")[(i = ((i + 1) | 0))])));
      valname = $thisType.remstartspaces($thisType.singlesplit(valname, "=")[1]);
    }
    if ($S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), "(")) {
      varname = $thisType.betwparen(varname)[0];
    }
    if (varname == valname) {
      $T05().WriteLine(JSIL.ConcatString.apply(null, JSIL.Array.New($T03(), ["Error: Cannot bind variable to itself, tried to bind \"", varname, "\" to \"", valname, "\""])));
      var result = true;
    } else if ($thisType.vars.ContainsKey(varname)) {
      if (!suppressdup) {
        $T05().WriteLine(JSIL.ConcatString.apply(null, JSIL.Array.New($T03(), ["Error: Value under name \"", varname, "\" already exists, bound to value \"", $thisType.vars.get_Item(varname), "\""])));
      }
      result = true;
    } else if ($thisType.wildcards.ContainsKey(varname)) {
      if (!suppressdup) {
        $T05().WriteLine(JSIL.ConcatString.apply(null, JSIL.Array.New($T03(), ["Error: Value under name \"", varname, "\" already exists, bound to value \"", $thisType.wildcards.get_Item(varname), "\""])));
      }
      result = true;
    } else if ($T04().TryParse(varname, /* ref */ trash)) {
      $T05().WriteLine(("Error: Cannot bind directly to a numberic value, tried to bind to \"" + varname + "\""));
      result = true;
    } else {
      if (!((($thisType.split(s, "_if_").length | 0) !== 2) || (($thisType.split(s, "_then_").length | 0) !== 1))) {
        var res = $thisType.ParseMath($thisType.split(s, "_if_")[1]);
        if (res == "false") {
          result = true;
          return result;
        }
        if (!(res == "true")) {
          result = true;
          return result;
        }
        valname = $thisType.remspaces($thisType.split(valname, "_if_")[0]);
        if (varname == valname) {
          $T05().WriteLine(JSIL.ConcatString.apply(null, JSIL.Array.New($T03(), ["Error: Cannot bind variable to itself, tried to bind \"", varname, "\" to \"", valname, "\""])));
          result = true;
          return result;
        }
        var text = varname;

      $loop2: 
        for (var l = 0; l < (text.length | 0); l = ((l + 1) | 0)) {
          var j = (text[l]);
          if (!(((j.charCodeAt(0) | 0) < (("A").charCodeAt(0) | 0)) || ((j.charCodeAt(0) | 0) > (("Z").charCodeAt(0) | 0)))) {
            haswildcard = true;
            break $loop2;
          }
        }
        if (!haswildcard) {
          $thisType.vars.Add(varname, valname);
        } else {
          $thisType.wildcards.Add(varname, valname);
        }
      } else {
        var text2 = varname;

      $loop1: 
        for (var m = 0; m < (text2.length | 0); m = ((m + 1) | 0)) {
          var k = (text2[m]);
          if (!(((k.charCodeAt(0) | 0) < (("A").charCodeAt(0) | 0)) || ((k.charCodeAt(0) | 0) > (("Z").charCodeAt(0) | 0)))) {
            haswildcard = true;
            break $loop1;
          }
        }
        if (!haswildcard) {
          $thisType.vars.Add(varname, valname);
        } else {
          $thisType.wildcards.Add(varname, valname);
        }
      }
      result = true;
    }
    return result;
  };

  function Parser_listsplit (s, splitter, $exception) {
    var ret = $S03().Construct();
    var temp = "";
    var isinarr = 0;

    for (var i = 0; i < (s.length | 0); i = ((i + 1) | 0)) {
      try {
        if (!((((s[i]).charCodeAt(0) | 0) !== (("[").charCodeAt(0) | 0)) && (((s[i]).charCodeAt(0) | 0) !== (("{").charCodeAt(0) | 0)))) {
          isinarr = ((isinarr + 1) | 0);
        }
        if (!((((s[i]).charCodeAt(0) | 0) !== (("]").charCodeAt(0) | 0)) && (((s[i]).charCodeAt(0) | 0) !== (("}").charCodeAt(0) | 0)))) {
          isinarr = ((isinarr - 1) | 0);
        }
        if (!(!(s.substr(i, splitter.length) == splitter) || (isinarr !== 0))) {
          ret.Add(temp);
          temp = "";
          i = ((i + (((splitter.length | 0) - 1) | 0)) | 0);
        } else {
          temp = (JSIL.ConcatString(temp, s.substr(i, 1)));
        }
      } catch ($exception) {
        temp = (JSIL.ConcatString(temp, s.substr(i, 1)));
      }
    }
    ret.Add(temp);
    return $T07().prototype.ToArray.call(ret);
  };

  function Parser_mapf (f, l) {
    var $lmapf$gc__AnonStorey = new ($T12())();
    $lmapf$gc__AnonStorey.f = f;
    var res = "[";
    if ($thisType.vars.ContainsKey(l)) {
      l = $thisType.parseMath($thisType.vars.get_Item(l));
    }
    if ($thisType.vars.ContainsKey($lmapf$gc__AnonStorey.f)) {
      $lmapf$gc__AnonStorey.f = $thisType.parseMath($thisType.vars.get_Item($lmapf$gc__AnonStorey.f));
    }
    if (!$thisType.isarray(l)) {
      $T05().WriteLine("Error: Cannot map function to non-list value. Aborting operation.");
      var result = "";
    } else {
      var num = $T0C().ToArray$b1($T03())($S08().CallStatic($T0C(), "Select$b2", [$asm01.System.String, $asm01.System.String], 
          $thisType.listsplit($thisType.betwbracks(l)[0], ","), 
          $T13().New($lmapf$gc__AnonStorey, $T12().prototype.$l$gm__0, function () { return JSIL.GetMethodInfo($asm00.HSCi.Parser_$lmapf$gc__AnonStorey0, "$l$gm__0", new JSIL.MethodSignature($asm01.System.String, [$asm01.System.String]), false); })
        ));
      var array = num;

      for (var j = 0; j < (array.length | 0); j = ((j + 1) | 0)) {
        var i = array[j];
        res = ((res + i + ","));
      }
      res = (res.substr(0, (((res.length | 0) - 1) | 0)));
      res = (JSIL.ConcatString(res, "]"));
      result = res;
    }
    return result;
  };

  function Parser_mapToVars (s, mapto) {
    var varname = $thisType.remspaces($thisType.split(s.substr(5), "=")[0]);
    var valname = $thisType.remstartspaces($thisType.singlesplit(s.substr(5), "=")[1]);
    var i = 0;

    while ($S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), "(") && !$S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), ")")) {
      varname = ((varname + "=" + $thisType.remspaces($thisType.split(s.substr(5), "=")[(i = ((i + 1) | 0))])));
      valname = $thisType.remstartspaces($thisType.singlesplit(valname, "=")[1]);
    }
    if ($S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), "(")) {
      varname = $thisType.betwparen(varname)[0];
    }
    if (varname == valname) {
      $T05().WriteLine(JSIL.ConcatString.apply(null, JSIL.Array.New($T03(), ["Error: Cannot bind variable to itself, tried to bind \"", varname, "\" to \"", valname, "\""])));
      var result = "";
    } else {
      mapto = ((" " + mapto + " "));

      for (var j = 0; j < (((((mapto.length | 0) - (varname.length | 0)) | 0) + 1) | 0); j = ((j + 1) | 0)) {
        if (mapto.substr(j, varname.length) == varname) {
          mapto = ((mapto.substr(0, j) + valname + mapto.substr(((j + (varname.length | 0)) | 0))));
        }
      }
      result = mapto;
    }
    return result;
  };

  function Parser_matches (test, str, $exception) {
    str = ((" " + str + " "));
    test = ((" " + test + " "));
    var varlist = $S00().Construct();

    for (var i = 0; i < (str.length | 0); i = ((i + 1) | 0)) {
      var dicttempkey = "";
      var dicttempvals = "";
      try {
        if (((str[i]).charCodeAt(0) | 0) !== ((test[i]).charCodeAt(0) | 0)) {
          if (!((((str[i]).charCodeAt(0) | 0) >= (("A").charCodeAt(0) | 0)) && (((str[i]).charCodeAt(0) | 0) <= (("Z").charCodeAt(0) | 0)))) {
            var result = new ($T14())(false, varlist);
            return result;
          }
          var strtemp = (str.substr(i));
          var testtemp = (test.substr(i));

          while (((((strtemp[0]).charCodeAt(0) | 0) >= (("a").charCodeAt(0) | 0)) && 
              (((strtemp[0]).charCodeAt(0) | 0) <= (("z").charCodeAt(0) | 0))) || ((((strtemp[0]).charCodeAt(0) | 0) >= (("A").charCodeAt(0) | 0)) && 
              (((strtemp[0]).charCodeAt(0) | 0) <= (("Z").charCodeAt(0) | 0)))) {
            dicttempkey = (JSIL.ConcatString(dicttempkey, strtemp[0]));
            strtemp = (strtemp.substr(1));
          }

          while (((((testtemp[0]).charCodeAt(0) | 0) >= (("0").charCodeAt(0) | 0)) && 
              (((testtemp[0]).charCodeAt(0) | 0) <= (("9").charCodeAt(0) | 0))) || 
            (((testtemp[0]).charCodeAt(0) | 0) === (("-").charCodeAt(0) | 0)) || 
            (((testtemp[0]).charCodeAt(0) | 0) === ((".").charCodeAt(0) | 0)) || 
            ((((testtemp[0]).charCodeAt(0) | 0) >= (("a").charCodeAt(0) | 0)) && 
              (((testtemp[0]).charCodeAt(0) | 0) <= (("z").charCodeAt(0) | 0))) || ((((testtemp[0]).charCodeAt(0) | 0) === (("[").charCodeAt(0) | 0)) && 
              (dicttempvals == ""))) {
            if (((testtemp[0]).charCodeAt(0) | 0) === (("[").charCodeAt(0) | 0)) {
              var cnt = 0;

              do {
                if (((testtemp[0]).charCodeAt(0) | 0) === (("]").charCodeAt(0) | 0)) {
                  cnt = ((cnt - 1) | 0);
                }
                if (((testtemp[0]).charCodeAt(0) | 0) === (("[").charCodeAt(0) | 0)) {
                  cnt = ((cnt + 1) | 0);
                }
                dicttempvals = (JSIL.ConcatString(dicttempvals, testtemp[0]));
                testtemp = (testtemp.substr(1));
              } while (cnt !== 0);
            } else {
              dicttempvals = (JSIL.ConcatString(dicttempvals, testtemp[0]));
              testtemp = (testtemp.substr(1));
            }
          }
          test = (JSIL.ConcatString(test.substr(0, ((i - 1) | 0)), testtemp));
          str = (JSIL.ConcatString(str.substr(0, ((i - 1) | 0)), strtemp));
          i = ((i - 2) | 0);
          varlist.Add(dicttempkey, dicttempvals);
        }
      } catch ($exception) {
        result = new ($T14())(false, varlist);
        return result;
      }
    }
    if ((str.length | 0) !== (test.length | 0)) {
      result = new ($T14())(false, varlist);
      return result;
    }
    if (!(!$T00().prototype.ContainsValue.call(varlist, "") && !varlist.ContainsKey(""))) {
      result = new ($T14())(false, varlist);
      return result;
    }
    result = new ($T14())(true, varlist);
    return result;
  };

  function Parser_modu (s, base_) {
    var num = new JSIL.BoxedVariable(0);
    var num2 = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if ($thisType.vars.ContainsKey(base_)) {
      base_ = $thisType.parseMath($thisType.vars.get_Item(base_));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot take modulo with argument of nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else if (!$T04().TryParse(base_, /* ref */ num2)) {
      $T05().WriteLine("Error: Cannot take modulo with argument of nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      result = "";
    } else {
      num.set(+num.get() % +num2.get());
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  function Parser_nlog (s, base_) {
    var num = new JSIL.BoxedVariable(0);
    var num2 = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if ($thisType.vars.ContainsKey(base_)) {
      base_ = $thisType.parseMath($thisType.vars.get_Item(base_));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot take log of a nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else if (!$T04().TryParse(base_, /* ref */ num2)) {
      $T05().WriteLine("Error: Cannot take log with base of a nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      result = "";
    } else {
      num.set(((Math.log(num.get()) / Math.log(num2.get()))));
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  function Parser_notlet (s) {
    var varname = $thisType.fixneg($thisType.remspaces($thisType.split(s.substr(5), "/=")[0]));
    var valname = $thisType.remstartspaces($thisType.singlesplit(s.substr(5), "/=")[1]);
    var haswildcard = false;
    var i = 0;

    while ($S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), "(") && !$S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), ")")) {
      varname = ((varname + "/=" + $thisType.remspaces($thisType.split(s.substr(5), "/=")[(i = ((i + 1) | 0))])));
      valname = $thisType.remstartspaces($thisType.singlesplit(valname, "/=")[1]);
    }
    if ($S05().CallVirtual("Contains", null, $T0C().ToList$b1($T08())(varname), "(")) {
      varname = $thisType.betwparen(varname)[0];
    }
    if (varname == valname) {
      $T05().WriteLine(JSIL.ConcatString.apply(null, JSIL.Array.New($T03(), ["Error: Cannot break reflexive law of equality, tried to say \"", varname, "\" is not equal to \"", valname, "\""])));
      var result = true;
    } else {
      if ($thisType.vars.ContainsKey(varname)) {
        $T05().WriteLine(JSIL.ConcatString.apply(null, JSIL.Array.New($T03(), ["Error: Value under name \"", varname, "\" already exists, bound to value \"", $thisType.vars.get_Item(varname), "\""])));
      } else if (!((($thisType.split(s, "_if_").length | 0) !== 2) || (($thisType.split(s, "_then_").length | 0) !== 1))) {
        var res = $thisType.ParseMath($thisType.split(s, "_if_")[1]);
        if (res == "false") {
          result = true;
          return result;
        }
        if (!(res == "true")) {
          result = true;
          return result;
        }
        valname = $thisType.remspaces($thisType.split(valname, "_if_")[0]);
        if (varname == valname) {
          $T05().WriteLine(JSIL.ConcatString.apply(null, JSIL.Array.New($T03(), ["Error: Cannot break reflexive law of equality, tried to say \"", varname, "\" is not equal to \"", valname, "\""])));
          result = true;
          return result;
        }
        var text = valname;

      $loop2: 
        for (var l = 0; l < (text.length | 0); l = ((l + 1) | 0)) {
          var j = (text[l]);
          if (!(((j.charCodeAt(0) | 0) < (("A").charCodeAt(0) | 0)) || ((j.charCodeAt(0) | 0) > (("Z").charCodeAt(0) | 0)))) {
            haswildcard = true;
            break $loop2;
          }
        }
        if (!haswildcard) {
          $thisType.vars.Add(varname, "unknown");
          $thisType.vars.Add((varname + "=" + valname), "false");
          $thisType.vars.Add((valname + "=" + varname), "false");
          $thisType.vars.Add((varname + "/=" + valname), "true");
          $thisType.vars.Add((valname + "/=" + varname), "true");
        } else {
          $thisType.wildcards.Add(varname, "unknown");
          $thisType.wildcards.Add((varname + "=" + valname), "false");
          $thisType.wildcards.Add((valname + "=" + varname), "false");
          $thisType.wildcards.Add((varname + "/=" + valname), "true");
          $thisType.wildcards.Add((valname + "/=" + varname), "true");
        }
      } else {
        var text2 = valname;

      $loop1: 
        for (var m = 0; m < (text2.length | 0); m = ((m + 1) | 0)) {
          var k = (text2[m]);
          if (!(((k.charCodeAt(0) | 0) < (("A").charCodeAt(0) | 0)) || ((k.charCodeAt(0) | 0) > (("Z").charCodeAt(0) | 0)))) {
            haswildcard = true;
            break $loop1;
          }
        }
        if (!haswildcard) {
          $thisType.vars.Add(varname, "unknown");
          $thisType.vars.Add((varname + "=" + valname), "false");
          $thisType.vars.Add((valname + "=" + varname), "false");
          $thisType.vars.Add((varname + "/=" + valname), "true");
          $thisType.vars.Add((valname + "/=" + varname), "true");
        } else {
          $thisType.wildcards.Add(varname, "unknown");
          $thisType.wildcards.Add((varname + "=" + valname), "false");
          $thisType.wildcards.Add((valname + "=" + varname), "false");
          $thisType.wildcards.Add((varname + "/=" + valname), "true");
          $thisType.wildcards.Add((valname + "/=" + varname), "true");
        }
      }
      result = true;
    }
    return result;
  };

  function Parser_parseMath (s, $exception) {
    var trash = new JSIL.BoxedVariable(0);
    if ($T04().TryParse(s, /* ref */ trash)) {
      var result = $thisType.remspaces(s);
    } else {
      try {
        s = $thisType.remspaces(s);
        s = $thisType.fixneg(s);
        s = $thisType.testinternal(s);
        if ($thisType.vars.ContainsKey(s)) {
          s = $thisType.parseMath($thisType.vars.get_Item(s));
        }
        var enumerator = $IM00().Call($T0C().Reverse$b1($T03())($T0C().ToArray$b1($T03())($thisType.wildcards.get_Keys())), null);
        try {

          while ($IM01().Call(enumerator, null)) {
            var stemp = $IM02().Call(enumerator, null);
            var temp = $thisType.matches(s, stemp);
            if (temp.get_Item1()) {
              s = $thisType.wildcards.get_Item(stemp);
              var enumerator2 = ((temp.get_Item2()).get_Keys()).GetEnumerator();

              while ($T18().prototype.MoveNext.call(enumerator2)) {
                var sdict = $T18().prototype.get_Current.call(enumerator2);
                s = $thisType.mapToVars(("_let_" + sdict + "=" + (temp.get_Item2()).get_Item(sdict)), s);
              }
              s = $thisType.parseMath(s);
              var enumerator3 = ((temp.get_Item2()).get_Keys()).GetEnumerator();

              while ($T18().prototype.MoveNext.call(enumerator3)) {
                var sdict2 = $T18().prototype.get_Current.call(enumerator3);
                $thisType.forget(("_let_" + sdict2 + "=" + (temp.get_Item2()).get_Item(sdict2)));
              }
            }
          }
        } finally {
          if (enumerator !== null) {
            $IM03().Call(enumerator, null);
          }
        }
        if (($thisType.betwparen(s).length | 0) > 0) {
          var array = $thisType.betwparen(s);

          for (var num = 0; num < (array.length | 0); num = ((num + 1) | 0)) {
            var i = array[num];
            s = (($thisType.split(s, "(")[0] + $thisType.parseMath(i) + s.substr(((((($thisType.split(s, "(")[0].length | 0) + (i.length | 0)) | 0) + 2) | 0))));
          }
        }
        if (($thisType.betwbraces(s).length | 0) > 0) {
          var array2 = $thisType.betwbraces(s);

          for (var num2 = 0; num2 < (array2.length | 0); num2 = ((num2 + 1) | 0)) {
            var j = array2[num2];
            s = (JSIL.ConcatString.apply(null, JSIL.Array.New($T03(), [$thisType.split(s, "{")[0], "{", $thisType.parseMath(j), "}", s.substr(((((($thisType.split(s, "{")[0].length | 0) + (j.length | 0)) | 0) + 2) | 0))])));
          }
        }
        if ($thisType.vars.ContainsKey(s)) {
          s = $thisType.parseMath($thisType.vars.get_Item(s));
        }
        var enumerator4 = $IM00().Call($T0C().Reverse$b1($T03())($T0C().ToArray$b1($T03())($thisType.wildcards.get_Keys())), null);
        try {

          while ($IM01().Call(enumerator4, null)) {
            var stemp2 = $IM02().Call(enumerator4, null);
            var temp2 = $thisType.matches(s, stemp2);
            if (temp2.get_Item1()) {
              s = $thisType.wildcards.get_Item(stemp2);
              var enumerator5 = ((temp2.get_Item2()).get_Keys()).GetEnumerator();

              while ($T18().prototype.MoveNext.call(enumerator5)) {
                var sdict3 = $T18().prototype.get_Current.call(enumerator5);
                s = $thisType.mapToVars(("_let_" + sdict3 + "=" + (temp2.get_Item2()).get_Item(sdict3)), s);
              }
              s = $thisType.parseMath(s);
              var enumerator6 = ((temp2.get_Item2()).get_Keys()).GetEnumerator();

              while ($T18().prototype.MoveNext.call(enumerator6)) {
                var sdict4 = $T18().prototype.get_Current.call(enumerator6);
                $thisType.forget(("_let_" + sdict4 + "=" + (temp2.get_Item2()).get_Item(sdict4)));
              }
            }
          }
        } finally {
          if (enumerator4 !== null) {
            $IM03().Call(enumerator4, null);
          }
        }
        if (($thisType.split(s, "_where_").length | 0) > 1) {
          var temps = (JSIL.ConcatString("_let_", $thisType.singlesplit(s, "_where_")[1]));
          if ((($S07().CallStatic($T0C(), "Last$b1", [$asm01.System.Char], $thisType.split(temps, "=")[0])).charCodeAt(0) | 0) === (("/").charCodeAt(0) | 0)) {
            $T05().WriteLine("Error: Cannot use /= in \"where\" predicate.");
            result = "";
            return result;
          }
          if (!((($thisType.split(temps, "_if_").length | 0) <= 1) || (($thisType.split(temps, "_then_").length | 0) !== 1))) {
            $T05().WriteLine("Error: Cannot use \"if\" predicate off of \"where\" predicate, only \"let\" commands.");
            result = "";
            return result;
          }
          $thisType.$let(temps, true);
          s = $thisType.parseMath($thisType.split(s, "_where_")[0]);
          $thisType.forget(temps);
        }
        if (($thisType.split(s, "_if_").length | 0) > 1) {
          if (!(!($thisType.parseMath($thisType.split($thisType.split(s, "_if_")[1], "_then_")[0]) != "true") || !($thisType.parseMath($thisType.split($thisType.split(s, "_if_")[1], "_then_")[0]) != "false"))) {
            $T05().WriteLine(("Error: Expected boolean expression, received \"" + $thisType.split($thisType.split(s, "_if_")[1], "_then_")[0] + "\""));
          } else if ($thisType.parseMath($thisType.split($thisType.split(s, "_if_")[1], "_then_")[0]) == "true") {
            try {
              s = (JSIL.ConcatString($thisType.split(s, "_if_")[0], $thisType.parseMath($thisType.split($thisType.split(s, "_then_")[1], "_else_")[0])));
            } catch ($exception) {
            }
          } else if ($thisType.parseMath($thisType.split($thisType.split(s, "_if_")[1], "_then_")[0]) == "false") {
            s = (JSIL.ConcatString($thisType.split(s, "_if_")[0], $thisType.parseMath($thisType.singlesplit(s, "_else_")[1])));
          }
        }
        if (($thisType.betwbracks(s).length | 0) > 0) {
          var array3 = $thisType.betwbracks(s);

          for (var num3 = 0; num3 < (array3.length | 0); num3 = ((num3 + 1) | 0)) {
            var k = array3[num3];
            try {
              var res = "";
              var b = false;
              var args = $S03().Construct();
              if (($thisType.split(k, "..").length | 0) === 2) {
                b = true;
                if (($thisType.betwbracks(k).length | 0) === 0) {
                  if (($thisType.split($thisType.split(k, "..")[0], ",").length | 0) === 2) {
                    args = $T0C().ToList$b1($T03())($S09().CallStatic($T0C(), "Select$b2", [$asm01.System.Int32, $asm01.System.String], 
                        $T1B().$Cast($thisType.range(
                            $S0A().CallStatic($T02(), "ToInt32", null, $thisType.parseMath($thisType.split($thisType.split(k, "..")[0], ",")[0])), 
                            ((($S0A().CallStatic($T02(), "ToInt32", null, $thisType.parseMath($thisType.split(k, "..")[1])) | 0) + 1) | 0), 
                            ((($S0A().CallStatic($T02(), "ToInt32", null, $thisType.parseMath($thisType.split($thisType.split(k, "..")[0], ",")[1])) | 0) - ($S0A().CallStatic($T02(), "ToInt32", null, $thisType.parseMath($thisType.split($thisType.split(k, "..")[0], ",")[0])) | 0)) | 0)
                          )), 
                        $T1C().New($thisType, $thisType.$lparseMath$gm__0, function () { return JSIL.GetMethodInfo($thisType, "$lparseMath$gm__0", new JSIL.MethodSignature($asm01.System.String, [$asm01.System.Int32]), true); })
                      ));
                  } else {
                    args = $T0C().ToList$b1($T03())($S09().CallStatic($T0C(), "Select$b2", [$asm01.System.Int32, $asm01.System.String], 
                        $T1B().$Cast($thisType.range(
                            $S0A().CallStatic($T02(), "ToInt32", null, $thisType.parseMath($thisType.split(k, "..")[0])), 
                            ((($S0A().CallStatic($T02(), "ToInt32", null, $thisType.parseMath($thisType.split(k, "..")[1])) | 0) + 1) | 0), 
                            1
                          )), 
                        $T1C().New($thisType, $thisType.$lparseMath$gm__1, function () { return JSIL.GetMethodInfo($thisType, "$lparseMath$gm__1", new JSIL.MethodSignature($asm01.System.String, [$asm01.System.Int32]), true); })
                      ));
                  }
                } else {
                  b = false;
                }
              }
              if (!b) {
                args = $T0C().ToList$b1($T03())($S08().CallStatic($T0C(), "Select$b2", [$asm01.System.String, $asm01.System.String], 
                    $T0C().Cast$b1($T03())($T1D().$Cast($thisType.listsplit(k, ","))), 
                    $T13().New($thisType, $thisType.$lparseMath$gm__2, function () { return JSIL.GetMethodInfo($thisType, "$lparseMath$gm__2", new JSIL.MethodSignature($asm01.System.String, [$asm01.System.String]), true); })
                  ));
              }

              for (var l = 0; l < (((args.get_Count() | 0) - 1) | 0); l = ((l + 1) | 0)) {
                res = ((res + $S0B().CallVirtual("get_Item", null, args, l) + ","));
              }
              res = (JSIL.ConcatString(res, $S0C().CallStatic($T0C(), "Last$b1", [$asm01.System.String], args)));
              s = (JSIL.ConcatString.apply(null, JSIL.Array.New($T03(), [$thisType.split(s, "[")[0], "\xab", res, "\xbb", s.substr(((((($thisType.split(s, "[")[0].length | 0) + (k.length | 0)) | 0) + 2) | 0))])));
            } catch ($exception) {
              $T05().WriteLine(("Error: Could not parse list \"[" + k + "]\". Assuming [], resuming operation."));
              s = (($thisType.split(s, "[")[0] + "\xab\xbb" + s.substr(((((($thisType.split(s, "[")[0].length | 0) + (k.length | 0)) | 0) + 2) | 0))));
            }
          }
          s = (JSIL.ConcatString(" ", s));

          for (var m = 0; m < (s.length | 0); m = ((m + 1) | 0)) {
            if (((s[m]).charCodeAt(0) | 0) === (("\xab").charCodeAt(0) | 0)) {
              s = (JSIL.ConcatString(s.substr(0, m), "[", s.substr(((m + 1) | 0))));
            }
            if (((s[m]).charCodeAt(0) | 0) === (("\xbb").charCodeAt(0) | 0)) {
              s = (JSIL.ConcatString(s.substr(0, m), "]", s.substr(((m + 1) | 0))));
            }
          }
          s = (s.substr(1));
        }
        if (($thisType.split(s, "_and_").length | 0) > 1) {
          var args2 = $thisType.split(s, "_and_");
          var array4 = args2;

          for (var num4 = 0; num4 < (array4.length | 0); num4 = ((num4 + 1) | 0)) {
            var n = array4[num4];
            if ($thisType.parseMath(n) == "false") {
              result = "false";
              return result;
            }
          }
          result = "true";
        } else if (($thisType.split(s, "_or_").length | 0) > 1) {
          var args3 = $thisType.split(s, "_or_");
          var array5 = args3;

          for (var num5 = 0; num5 < (array5.length | 0); num5 = ((num5 + 1) | 0)) {
            var i2 = array5[num5];
            if ($thisType.parseMath(i2) == "true") {
              result = "true";
              return result;
            }
          }
          result = "false";
        } else if (($thisType.split(s, "/=").length | 0) === 2) {
          var a = $thisType.parseMath($thisType.split(s, "/=")[0]);
          var b2 = $thisType.parseMath($thisType.split(s, "/=")[1]);
          if ($thisType.vars.ContainsKey(($thisType.split(s, "/=")[0] + "/=" + b2))) {
            result = $thisType.vars.get_Item(($thisType.split(s, "/=")[0] + "/=" + b2));
          } else if ($thisType.vars.ContainsKey((a + "/=" + $thisType.split(s, "/=")[1]))) {
            result = $thisType.vars.get_Item((a + "/=" + $thisType.split(s, "/=")[1]));
          } else if (!(!(a == "unknown") && !(b2 == "unknown"))) {
            result = "unknown";
          } else {
            result = (
              !(a != b2)
                 ? "false"
                 : "true")
            ;
          }
        } else if (($thisType.split(s, ">=").length | 0) === 2) {
          var a2 = $thisType.parseMath($thisType.split(s, ">=")[0]);
          var b3 = $thisType.parseMath($thisType.split(s, ">=")[1]);
          if (!(!(a2 == "unknown") && !(b3 == "unknown"))) {
            result = "unknown";
          } else {
            result = (
              (+$S06().CallStatic($T02(), "ToDouble", null, a2) < +$S06().CallStatic($T02(), "ToDouble", null, b3))
                 ? "false"
                 : "true")
            ;
          }
        } else if (($thisType.split(s, "<=").length | 0) === 2) {
          var a3 = $thisType.parseMath($thisType.split(s, "<=")[0]);
          var b4 = $thisType.parseMath($thisType.split(s, "<=")[1]);
          if (!(!(a3 == "unknown") && !(b4 == "unknown"))) {
            result = "unknown";
          } else {
            result = (
              (+$S06().CallStatic($T02(), "ToDouble", null, a3) > +$S06().CallStatic($T02(), "ToDouble", null, b4))
                 ? "false"
                 : "true")
            ;
          }
        } else if (($thisType.split(s, ">").length | 0) === 2) {
          var a4 = $thisType.parseMath($thisType.split(s, ">")[0]);
          var b5 = $thisType.parseMath($thisType.split(s, ">")[1]);
          if (!(!(a4 == "unknown") && !(b5 == "unknown"))) {
            result = "unknown";
          } else {
            result = (
              (+$S06().CallStatic($T02(), "ToDouble", null, a4) <= +$S06().CallStatic($T02(), "ToDouble", null, b5))
                 ? "false"
                 : "true")
            ;
          }
        } else if (($thisType.split(s, "<").length | 0) === 2) {
          var a5 = $thisType.parseMath($thisType.split(s, "<")[0]);
          var b6 = $thisType.parseMath($thisType.split(s, "<")[1]);
          if (!(!(a5 == "unknown") && !(b6 == "unknown"))) {
            result = "unknown";
          } else {
            result = (
              (+$S06().CallStatic($T02(), "ToDouble", null, a5) >= +$S06().CallStatic($T02(), "ToDouble", null, b6))
                 ? "false"
                 : "true")
            ;
          }
        } else if (($thisType.split(s, "=").length | 0) === 2) {
          var a6 = $thisType.parseMath($thisType.split(s, "=")[0]);
          var b7 = $thisType.parseMath($thisType.split(s, "=")[1]);
          if ($thisType.vars.ContainsKey(($thisType.split(s, "=")[0] + "=" + b7))) {
            result = $thisType.vars.get_Item(($thisType.split(s, "=")[0] + "=" + b7));
          } else if ($thisType.vars.ContainsKey((a6 + "=" + $thisType.split(s, "=")[1]))) {
            result = $thisType.vars.get_Item((a6 + "=" + $thisType.split(s, "=")[1]));
          } else if (!(!(a6 == "unknown") && !(b7 == "unknown"))) {
            result = "unknown";
          } else {
            result = (
              !(a6 == b7)
                 ? "false"
                 : "true")
            ;
          }
        } else {
          if (!((($thisType.singlesplit(s, "+").length | 0) !== 2) && (($thisType.singlesplit(s, "`").length | 0) !== 2))) {
            var nums = $S03().Construct();
            var ops = $S0D().Construct();
            var temp3 = "";
            var text = s;

            for (var num6 = 0; num6 < (text.length | 0); num6 = ((num6 + 1) | 0)) {
              var i3 = (text[num6]);
              if (!(((i3.charCodeAt(0) | 0) !== (("+").charCodeAt(0) | 0)) && ((i3.charCodeAt(0) | 0) !== (("`").charCodeAt(0) | 0)))) {
                nums.Add(temp3);
                ops.Add(i3);
                temp3 = "";
              } else {
                temp3 = (JSIL.ConcatString(temp3, i3));
              }
            }
            nums.Add(temp3);
            var array6 = $thisType.range(0, ops.get_Count(), 1);

            for (var num7 = 0; num7 < (array6.length | 0); num7 = ((num7 + 1) | 0)) {
              var i4 = String.fromCharCode(array6[num7]);
              if ((($S0E().CallVirtual("get_Item", null, ops, 0)).charCodeAt(0) | 0) === (("+").charCodeAt(0) | 0)) {
                try {
                  nums.set_Item(1, $S02().CallStatic($T02(), "ToString", null, +$S06().CallStatic($T02(), "ToDouble", null, $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums, 0))) + +$S06().CallStatic($T02(), "ToDouble", null, $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums, 1)))));
                } catch ($exception) {
                  if (!(!($S0B().CallVirtual("get_Item", null, nums, 1) == "") && !($S0B().CallVirtual("get_Item", null, nums, 0) == ""))) {
                    throw $S0F().Construct();
                  }
                  nums.set_Item(1, ($thisType.parseMath($S0B().CallVirtual("get_Item", null, nums, 0)) + "+" + $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums, 1))));
                }
                nums.RemoveAt(0);
                ops.RemoveAt(0);
              } else if ((($S0E().CallVirtual("get_Item", null, ops, 0)).charCodeAt(0) | 0) === (("`").charCodeAt(0) | 0)) {
                try {
                  nums.set_Item(1, $S02().CallStatic($T02(), "ToString", null, +$S06().CallStatic($T02(), "ToDouble", null, $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums, 0))) - +$S06().CallStatic($T02(), "ToDouble", null, $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums, 1)))));
                } catch ($exception) {
                  if (!(!($S0B().CallVirtual("get_Item", null, nums, 1) == "") && !($S0B().CallVirtual("get_Item", null, nums, 0) == ""))) {
                    throw $S0F().Construct();
                  }
                  nums.set_Item(1, ($thisType.parseMath($S0B().CallVirtual("get_Item", null, nums, 0)) + "-" + $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums, 1))));
                }
                nums.RemoveAt(0);
                ops.RemoveAt(0);
              }
            }
            s = $S0B().CallVirtual("get_Item", null, nums, 0);
          } else if (!((($thisType.singlesplit(s, "*").length | 0) !== 2) && (($thisType.singlesplit(s, "/").length | 0) !== 2))) {
            var nums2 = $S03().Construct();
            var ops2 = $S0D().Construct();
            var temp4 = "";
            var text2 = s;

            for (var num8 = 0; num8 < (text2.length | 0); num8 = ((num8 + 1) | 0)) {
              var i5 = (text2[num8]);
              if (!(((i5.charCodeAt(0) | 0) !== (("*").charCodeAt(0) | 0)) && ((i5.charCodeAt(0) | 0) !== (("/").charCodeAt(0) | 0)))) {
                nums2.Add(temp4);
                ops2.Add(i5);
                temp4 = "";
              } else {
                temp4 = (JSIL.ConcatString(temp4, i5));
              }
            }
            nums2.Add(temp4);
            var array7 = $thisType.range(0, ops2.get_Count(), 1);

            for (var num9 = 0; num9 < (array7.length | 0); num9 = ((num9 + 1) | 0)) {
              var i6 = (array7[num9] | 0);
              if ((($S0E().CallVirtual("get_Item", null, ops2, 0)).charCodeAt(0) | 0) === (("*").charCodeAt(0) | 0)) {
                try {
                  nums2.set_Item(1, $S02().CallStatic($T02(), "ToString", null, +$S06().CallStatic($T02(), "ToDouble", null, $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums2, 0))) * +$S06().CallStatic($T02(), "ToDouble", null, $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums2, 1)))));
                } catch ($exception) {
                  if (!(!($S0B().CallVirtual("get_Item", null, nums2, 1) == "") && !($S0B().CallVirtual("get_Item", null, nums2, 0) == ""))) {
                    throw $S0F().Construct();
                  }
                  nums2.set_Item(1, ($thisType.parseMath($S0B().CallVirtual("get_Item", null, nums2, 0)) + "*" + $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums2, 1))));
                }
                nums2.RemoveAt(0);
                ops2.RemoveAt(0);
              } else if ((($S0E().CallVirtual("get_Item", null, ops2, 0)).charCodeAt(0) | 0) === (("/").charCodeAt(0) | 0)) {
                try {
                  nums2.set_Item(1, $S02().CallStatic($T02(), "ToString", null, +((+$S06().CallStatic($T02(), "ToDouble", null, $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums2, 0))) / +$S06().CallStatic($T02(), "ToDouble", null, $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums2, 1)))))));
                } catch ($exception) {
                  if (!(!($S0B().CallVirtual("get_Item", null, nums2, 1) == "") && !($S0B().CallVirtual("get_Item", null, nums2, 0) == ""))) {
                    throw $S0F().Construct();
                  }
                  nums2.set_Item(1, ($thisType.parseMath($S0B().CallVirtual("get_Item", null, nums2, 0)) + "/" + $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums2, 1))));
                }
                nums2.RemoveAt(0);
                ops2.RemoveAt(0);
              }
            }
            s = $S0B().CallVirtual("get_Item", null, nums2, 0);
          } else if (($thisType.singlesplit(s, "^").length | 0) === 2) {
            var nums3 = $S03().Construct();
            var temp5 = "";
            var text3 = s;

            for (var num10 = 0; num10 < (text3.length | 0); num10 = ((num10 + 1) | 0)) {
              var i7 = (text3[num10]);
              if ((i7.charCodeAt(0) | 0) === (("^").charCodeAt(0) | 0)) {
                nums3.Add(temp5);
                temp5 = "";
              } else {
                temp5 = (JSIL.ConcatString(temp5, i7));
              }
            }
            nums3.Add(temp5);
            $T07().prototype.Reverse.call(nums3);
            var array8 = $thisType.range(0, (((nums3.get_Count() | 0) - 1) | 0), 1);

            for (var num11 = 0; num11 < (array8.length | 0); num11 = ((num11 + 1) | 0)) {
              var i8 = (array8[num11] | 0);
              try {
                nums3.set_Item(0, $S02().CallStatic($T02(), "ToString", null, Math.pow($S06().CallStatic($T02(), "ToDouble", null, $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums3, 1))), $S06().CallStatic($T02(), "ToDouble", null, $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums3, 0))))));
              } catch ($exception) {
                if (!(!($S0B().CallVirtual("get_Item", null, nums3, 1) == "") && !($S0B().CallVirtual("get_Item", null, nums3, 0) == ""))) {
                  throw $S0F().Construct();
                }
                nums3.set_Item(0, ($thisType.parseMath($S0B().CallVirtual("get_Item", null, nums3, 1)) + "^" + $thisType.parseMath($S0B().CallVirtual("get_Item", null, nums3, 0))));
              }
              nums3.RemoveAt(1);
            }
            s = $S0B().CallVirtual("get_Item", null, nums3, 0);
          } else {
            var enumerator7 = $IM00().Call($T0C().Reverse$b1($T03())($T0C().ToArray$b1($T03())($thisType.wildcards.get_Keys())), null);
            try {

              while ($IM01().Call(enumerator7, null)) {
                var stemp3 = $IM02().Call(enumerator7, null);
                var temp6 = $thisType.matches(s, stemp3);
                if (temp6.get_Item1()) {
                  s = $thisType.wildcards.get_Item(stemp3);
                  var enumerator8 = ((temp6.get_Item2()).get_Keys()).GetEnumerator();

                  while ($T18().prototype.MoveNext.call(enumerator8)) {
                    var sdict5 = $T18().prototype.get_Current.call(enumerator8);
                    s = $thisType.mapToVars(("_let_" + sdict5 + "=" + (temp6.get_Item2()).get_Item(sdict5)), s);
                  }
                  s = $thisType.parseMath(s);
                  var enumerator9 = ((temp6.get_Item2()).get_Keys()).GetEnumerator();

                  while ($T18().prototype.MoveNext.call(enumerator9)) {
                    var sdict6 = $T18().prototype.get_Current.call(enumerator9);
                    $thisType.forget(("_let_" + sdict6 + "=" + (temp6.get_Item2()).get_Item(sdict6)));
                  }
                }
              }
            } finally {
              if (enumerator7 !== null) {
                $IM03().Call(enumerator7, null);
              }
            }
          }
          s = $thisType.testinternal(s);
          if ($thisType.vars.ContainsKey(s)) {
            s = $thisType.parseMath($thisType.vars.get_Item(s));
          }
          if (!((($thisType.singlesplit(s, ".").length | 0) !== 2) || !($thisType.singlesplit(s, ".")[1] == "0"))) {
            s = $thisType.singlesplit(s, ".")[0];
          }
          result = s;
        }
      } catch ($exception) {
        $T05().WriteLine("Internal Error: Math Parser crashed upon parsing. Aborting operation.");
        result = "";
      }
    }
    return result;
  };

  function Parser_ParseMath (s, $exception) {
    if (($thisType.split(s, "//").length | 0) > 1) {
      s = $thisType.split(s, "//")[0];
    }
    var ret = $thisType.parseMath(s);
    if ($thisType.CAS) {
      var result = ret;
    } else {
      try {
        if (!(!(ret == "true") && 
            !(ret == "false") && 
            !(ret == "unknown") && 
            !(ret == "infinity") && 
            !$thisType.isarray(ret) && !($S02().CallStatic($T02(), "ToString", null, $S06().CallStatic($T02(), "ToDouble", null, ret)) == ret))) {
          result = ret;
          return result;
        }
      } catch ($exception) {
        result = (("Error: Could not parse query: \"" + s + "\""));
        return result;
      }
      result = "";
    }
    return result;
  };

  function Parser_Preprocessor (s, $exception) {
    s = (JSIL.ConcatString(" ", s));

    for (var i = 0; i < (s.length | 0); i = ((i + 1) | 0)) {
      try {
        if (!(!(s.substr(i, 2) == "if") || !$thisType.IsntSurrounded(s, i, 2))) {
          s = ((s.substr(0, i) + "_if_" + s.substr(((i + 2) | 0))));
        } else if (!(!(s.substr(i, 4) == "then") || !$thisType.IsntSurrounded(s, i, 4))) {
          s = ((s.substr(0, i) + "_then_" + s.substr(((i + 4) | 0))));
        } else if (!(!(s.substr(i, 4) == "else") || !$thisType.IsntSurrounded(s, i, 4))) {
          s = ((s.substr(0, i) + "_else_" + s.substr(((i + 4) | 0))));
        } else if (!(!(s.substr(i, 3) == "let") || !$thisType.IsntSurrounded(s, i, 3))) {
          s = ((s.substr(0, i) + "_let_" + s.substr(((i + 3) | 0))));
        } else if (!(!(s.substr(i, 3) == "and") || !$thisType.IsntSurrounded(s, i, 3))) {
          s = ((s.substr(0, i) + "_and_" + s.substr(((i + 3) | 0))));
        } else if (!(!(s.substr(i, 2) == "or") || !$thisType.IsntSurrounded(s, i, 2))) {
          s = ((s.substr(0, i) + "_or_" + s.substr(((i + 2) | 0))));
        } else if (!(!(s.substr(i, 5) == "where") || !$thisType.IsntSurrounded(s, i, 5))) {
          s = ((s.substr(0, i) + "_where_" + s.substr(((i + 5) | 0))));
        } else {
          i = ((i - 1) | 0);
        }
        i = ((i + 1) | 0);
      } catch ($exception) {
      }
    }
    return s;
  };

  function Parser_prnt (s) {
    s = $thisType.parseMath(s);
    $T05().WriteLine(s);
    return s;
  };

  function Parser_range (a, b, step) {
    var c = 0;
    var backs = false;
    if (!(((a | 0) <= (b | 0)) || ((step | 0) !== 1))) {
      backs = true;
      a = c = (((a | 0) + 1) | 0);
      b = a = (((b | 0) - 1) | 0);
      b = c;
    }
    if ((step | 0) < 0) {
      b = (((b | 0) - 2) | 0);
    }
    var res = $S10().Construct();

    for (var i = (a | 0); (
        ((step | 0) <= 0)
           ? (i > (b | 0))
           : (i < (b | 0)))
      ; i = ((i + (step | 0)) | 0)) {
      res.Add(i);
    }
    if (backs) {
      $T1F().prototype.Reverse.call(res);
    }
    return $T1F().prototype.ToArray.call(res);
  };

  function Parser_remspaces (s) {
    var res = "";

    for (var j = 0; j < (s.length | 0); j = ((j + 1) | 0)) {
      var i = (s[j]);
      if (!(((i.charCodeAt(0) | 0) === ((" ").charCodeAt(0) | 0)) || ((i.charCodeAt(0) | 0) === (("\t").charCodeAt(0) | 0)))) {
        res = (JSIL.ConcatString(res, i));
      }
    }
    return res;
  };

  function Parser_remstartspaces (s) {

    for (var i = 0; i < (s.length | 0); i = ((i + 1) | 0)) {
      if (((s[i]).charCodeAt(0) | 0) !== ((" ").charCodeAt(0) | 0)) {
        var result = (s.substr(i));
        return result;
      }
    }
    result = "";
    return result;
  };

  function Parser_rond (s) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot round a nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else {
      num.set((Math.floor((+num.get() + 0.5))));
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  function Parser_RunCommands (s, $exception) {
    if (($thisType.split(s, "//").length | 0) > 1) {
      s = $thisType.split(s, "//")[0];
    }
    s = $thisType.remstartspaces(s);
    try {
      if (s.substr(0, 5) == "_let_") {
        if ($thisType.split(s, "=")[0].substr(((($thisType.split(s, "=")[0].length | 0) - 1) | 0)) == "/") {
          var result = $thisType.notlet(s);
          return result;
        }
        result = $thisType.$let(s, false);
        return result;
      } else {
        if (s == "##disableCAS") {
          $thisType.CAS = false;
          result = true;
          return result;
        }
        if (s == "##enableCAS") {
          $thisType.CAS = true;
          result = true;
          return result;
        }
      }
    } catch ($exception) {
    }
    result = false;
    return result;
  };

  function Parser_sine (s) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot take sine of nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else {
      num.set((Math.sin(num.get())));
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  function Parser_singlesplit (s, splitter, $exception) {
    var ret = $S03().Construct();
    var temp = "";
    var alrsplt = false;

    for (var i = 0; i < (s.length | 0); i = ((i + 1) | 0)) {
      try {
        if (!(!(s.substr(i, splitter.length) == splitter) || alrsplt)) {
          ret.Add(temp);
          temp = "";
          i = ((i + (((splitter.length | 0) - 1) | 0)) | 0);
          alrsplt = true;
        } else {
          temp = (JSIL.ConcatString(temp, s.substr(i, 1)));
        }
      } catch ($exception) {
        temp = (JSIL.ConcatString(temp, s.substr(i, 1)));
      }
    }
    ret.Add(temp);
    return $T07().prototype.ToArray.call(ret);
  };

  function Parser_split (s, splitter, $exception) {
    var ret = $S03().Construct();
    var temp = "";

    for (var i = 0; i < (s.length | 0); i = ((i + 1) | 0)) {
      try {
        if (s.substr(i, splitter.length) == splitter) {
          ret.Add(temp);
          temp = "";
          i = ((i + (((splitter.length | 0) - 1) | 0)) | 0);
        } else {
          temp = (JSIL.ConcatString(temp, s.substr(i, 1)));
        }
      } catch ($exception) {
        temp = (JSIL.ConcatString(temp, s.substr(i, 1)));
      }
    }
    ret.Add(temp);
    return $T07().prototype.ToArray.call(ret);
  };

  function Parser_tang (s) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot take tangent of nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else {
      num.set((Math.tan(num.get())));
      if (!((+num.get() <= -286411217403672) || (+num.get() >= -286411217403670))) {
        result = "infinity";
      } else {
        result = $S02().CallStatic($T02(), "ToString", null, num.get());
      }
    }
    return result;
  };

  function Parser_testinternal (s, $exception) {
    var num = new JSIL.BoxedVariable(0);
    try {
      if (!(((s.length | 0) <= 16) || !(s.substr(0, 12) == "internalcmmd"))) {
        var text = (s.substr(12, 4));
        if (text !== null) {
          if ($thisType.$l$gf__switch$map0 === null) {
            var dictionary = $S11().Construct(17);
            dictionary.Add("sine", 0);
            dictionary.Add("cosi", 1);
            dictionary.Add("tang", 2);
            dictionary.Add("asin", 3);
            dictionary.Add("acos", 4);
            dictionary.Add("atan", 5);
            dictionary.Add("prnt", 6);
            dictionary.Add("flor", 7);
            dictionary.Add("rond", 8);
            dictionary.Add("ceil", 9);
            dictionary.Add("trun", 10);
            dictionary.Add("modu", 11);
            dictionary.Add("nlog", 12);
            dictionary.Add("getl", 13);
            dictionary.Add("mapf", 14);
            dictionary.Add("filt", 15);
            dictionary.Add("gama", 16);
            $thisType.$l$gf__switch$map0 = dictionary;
          }
          if ($thisType.$l$gf__switch$map0.TryGetValue(text, /* ref */ num)) {
            switch (num.get()) {
              case 0: 
                s = $thisType.sine(s.substr(16));
                break;

              case 1: 
                s = $thisType.cosi(s.substr(16));
                break;

              case 2: 
                s = $thisType.tang(s.substr(16));
                break;

              case 3: 
                s = $thisType.asin(s.substr(16));
                break;

              case 4: 
                s = $thisType.acos(s.substr(16));
                break;

              case 5: 
                s = $thisType.atan(s.substr(16));
                break;

              case 6: 
                s = $thisType.prnt(s.substr(16));
                break;

              case 7: 
                s = $thisType.flor(s.substr(16));
                break;

              case 8: 
                s = $thisType.rond(s.substr(16));
                break;

              case 9: 
                s = $thisType.ceil(s.substr(16));
                break;

              case 10: 
                s = $thisType.trun(s.substr(16));
                break;

              case 11: 
                s = $thisType.modu(
                  $thisType.split(s.substr(16), ",")[0], 
                  $thisType.split(s.substr(16), ",")[1]
                );
                break;

              case 12: 
                s = $thisType.nlog(
                  $thisType.split(s.substr(16), ",")[0], 
                  $thisType.split(s.substr(16), ",")[1]
                );
                break;

              case 13: 
                s = $thisType.getl(
                  $thisType.listsplit(s.substr(16), ",")[0], 
                  $thisType.listsplit(s.substr(16), ",")[1]
                );
                break;

              case 14: 
                s = $thisType.mapf(
                  $thisType.listsplit(s.substr(16), ",")[0], 
                  $thisType.listsplit(s.substr(16), ",")[1]
                );
                break;

              case 15: 
                s = $thisType.filt(
                  $thisType.listsplit(s.substr(16), ",")[0], 
                  $thisType.listsplit(s.substr(16), ",")[1]
                );
                break;

              case 16: 
                var temps = $thisType.parseMath(s.substr(16));
                s = $thisType.gama(temps);
                if (!((($thisType.split(temps, ".").length | 0) !== 1) || (($thisType.split(s, "+").length | 0) !== 1))) {
                  s = $thisType.split(s, ".")[0];
                }
                break;

            }
          }
        }
      }
    } catch ($exception) {
    }
    return s;
  };

  function Parser_trun (s) {
    var num = new JSIL.BoxedVariable(0);
    if ($thisType.vars.ContainsKey(s)) {
      s = $thisType.parseMath($thisType.vars.get_Item(s));
    }
    if (!$T04().TryParse(s, /* ref */ num)) {
      $T05().WriteLine("Error: Cannot truncate a nonnumeric value (includes booleans, unknown variables, or infinity). Aborting operation.");
      var result = "";
    } else {
      num.set(((num.get() | 0)));
      result = $S02().CallStatic($T02(), "ToString", null, num.get());
    }
    return result;
  };

  JSIL.MakeStaticClass("HSCi.Parser", false, [], function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:true , Public:false}, "$lparseMath$gm__0", 
      new JSIL.MethodSignature($.String, [$.Int32]), 
      Parser_$lparseMath$gm__0
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:true , Public:false}, "$lparseMath$gm__1", 
      new JSIL.MethodSignature($.String, [$.Int32]), 
      Parser_$lparseMath$gm__1
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:true , Public:false}, "$lparseMath$gm__2", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_$lparseMath$gm__2
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:true , Public:false}, "acos", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_acos
    );

    $.Method({Static:true , Public:false}, "asin", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_asin
    );

    $.Method({Static:true , Public:false}, "atan", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_atan
    );

    $.Method({Static:true , Public:false}, "betwbraces", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.String]), [$.String]), 
      Parser_betwbraces
    );

    $.Method({Static:true , Public:false}, "betwbracks", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.String]), [$.String]), 
      Parser_betwbracks
    );

    $.Method({Static:true , Public:false}, "betwparen", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.String]), [$.String]), 
      Parser_betwparen
    );

    $.Method({Static:true , Public:false}, "ceil", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_ceil
    );

    $.Method({Static:true , Public:false}, "cosi", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_cosi
    );

    $.Method({Static:true , Public:true }, "EffPrep", 
      JSIL.MethodSignature.Action($.String), 
      Parser_EffPrep
    );

    $.Method({Static:true , Public:false}, "filt", 
      new JSIL.MethodSignature($.String, [$.String, $.String]), 
      Parser_filt
    );

    $.Method({Static:true , Public:false}, "fixneg", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_fixneg
    );

    $.Method({Static:true , Public:false}, "flor", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_flor
    );

    $.Method({Static:true , Public:false}, "forget", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      Parser_forget
    );

    $.Method({Static:true , Public:false}, "gama", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_gama
    );

    $.Method({Static:true , Public:false}, "getl", 
      new JSIL.MethodSignature($.String, [$.String, $.String]), 
      Parser_getl
    );

    $.Method({Static:true , Public:false}, "isarray", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      Parser_isarray
    );

    $.Method({Static:true , Public:false}, "IsntSurrounded", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.Int32, 
          $.Int32
        ]), 
      Parser_IsntSurrounded
    );

    $.Method({Static:true , Public:false}, "$let", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.Boolean]), 
      Parser_let
    );

    $.Method({Static:true , Public:false}, "listsplit", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.String]), [$.String, $.String]), 
      Parser_listsplit
    );

    $.Method({Static:true , Public:false}, "mapf", 
      new JSIL.MethodSignature($.String, [$.String, $.String]), 
      Parser_mapf
    );

    $.Method({Static:true , Public:false}, "mapToVars", 
      new JSIL.MethodSignature($.String, [$.String, $.String]), 
      Parser_mapToVars
    );

    $.Method({Static:true , Public:false}, "matches", 
      new JSIL.MethodSignature($asm01.TypeRef("System.Tuple`2", [$.Boolean, $asm01.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $.String])]), [$.String, $.String]), 
      Parser_matches
    );

    $.Method({Static:true , Public:false}, "modu", 
      new JSIL.MethodSignature($.String, [$.String, $.String]), 
      Parser_modu
    );

    $.Method({Static:true , Public:false}, "nlog", 
      new JSIL.MethodSignature($.String, [$.String, $.String]), 
      Parser_nlog
    );

    $.Method({Static:true , Public:false}, "notlet", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      Parser_notlet
    );

    $.Method({Static:true , Public:false}, "parseMath", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_parseMath
    );

    $.Method({Static:true , Public:true }, "ParseMath", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_ParseMath
    );

    $.Method({Static:true , Public:true }, "Preprocessor", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_Preprocessor
    );

    $.Method({Static:true , Public:false}, "prnt", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_prnt
    );

    $.Method({Static:true , Public:false}, "range", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Int32]), [
          $.Int32, $.Int32, 
          $.Int32
        ]), 
      Parser_range
    );

    $.Method({Static:true , Public:false}, "remspaces", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_remspaces
    );

    $.Method({Static:true , Public:false}, "remstartspaces", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_remstartspaces
    );

    $.Method({Static:true , Public:false}, "rond", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_rond
    );

    $.Method({Static:true , Public:true }, "RunCommands", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      Parser_RunCommands
    );

    $.Method({Static:true , Public:false}, "sine", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_sine
    );

    $.Method({Static:true , Public:false}, "singlesplit", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.String]), [$.String, $.String]), 
      Parser_singlesplit
    );

    $.Method({Static:true , Public:false}, "split", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.String]), [$.String, $.String]), 
      Parser_split
    );

    $.Method({Static:true , Public:false}, "tang", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_tang
    );

    $.Method({Static:true , Public:false}, "testinternal", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_testinternal
    );

    $.Method({Static:true , Public:false}, "trun", 
      new JSIL.MethodSignature($.String, [$.String]), 
      Parser_trun
    );

    $.Field({Static:true , Public:true }, "vars", $asm01.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $.String])); 
    $.Field({Static:true , Public:true }, "wildcards", $asm01.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $.String])); 
    $.Field({Static:true , Public:false}, "CAS", $.Boolean, true); 
    $.Field({Static:true , Public:false}, "$l$gf__switch$map0", $asm01.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $.Int32]))
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:true , Public:false}, "$l$gf__am$cache0", $asm01.TypeRef("System.Func`2", [$.Int32, $.String]))
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:true , Public:false}, "$l$gf__am$cache1", $asm01.TypeRef("System.Func`2", [$.Int32, $.String]))
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:true , Public:false}, "$l$gf__am$cache2", $asm01.TypeRef("System.Func`2", [$.String, $.String]))
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function Parser__cctor () {
      $thisType.vars = $S00().Construct();
      $thisType.wildcards = $S00().Construct();
      $thisType.CAS = true;
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      Parser__cctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class HSCi.Parser+<mapf>c__AnonStorey0 */ 

(function $lmapf$gc__AnonStorey0$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm01.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm00.HSCi.Parser)) ();
  };

  function $lmapf$gc__AnonStorey0__ctor () {
  };

  function $lmapf$gc__AnonStorey0_$l$gm__0 (x) {
    return $T01().parseMath((this.f + "[" + x + "]"));
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "HSCi.Parser+<mapf>c__AnonStorey0", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $lmapf$gc__AnonStorey0__ctor
    );

    $.Method({Static:false, Public:false}, "$l$gm__0", 
      new JSIL.MethodSignature($.String, [$.String]), 
      $lmapf$gc__AnonStorey0_$l$gm__0
    );

    $.Field({Static:false, Public:false}, "f", $.String); 
    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class HSCi.Parser+<filt>c__AnonStorey1 */ 

(function $lfilt$gc__AnonStorey1$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm01.System.String)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm00.HSCi.Parser)) ();
  };

  function $lfilt$gc__AnonStorey1__ctor () {
  };

  function $lfilt$gc__AnonStorey1_$l$gm__0 (x) {
    return $T01().parseMath((this.f + "[" + x + "]")) == "true";
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "HSCi.Parser+<filt>c__AnonStorey1", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $lfilt$gc__AnonStorey1__ctor
    );

    $.Method({Static:false, Public:false}, "$l$gm__0", 
      new JSIL.MethodSignature($.Boolean, [$.String]), 
      $lfilt$gc__AnonStorey1_$l$gm__0
    );

    $.Field({Static:false, Public:false}, "f", $.String); 
    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class HSCi.MainLoop */ 

(function MainLoop$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm01.System.Collections.Generic.Dictionary$b2.Of($asm01.System.String, $asm01.System.String))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm00.HSCi.Parser)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm01.System.Convert)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize(System.Array.Of($asm01.System.String))) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm01.System.Exception)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm01.System.Int32)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm01.System.String)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm01.System.IO.File)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm01.System.Collections.Generic.List$b1.Of($asm01.System.String))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm01.System.Environment)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm01.System.Char)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm01.System.Console)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.String"), [$asm01.TypeRef("System.Double")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm01.TypeRef("System.Collections.Generic.List`1", [$asm01.TypeRef("System.String")]), null))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm01.TypeRef("System.String"), [$asm01.TypeRef("System.Int32")]))) ();
  };

  function MainLoop__ctor () {
  };

  function MainLoop_AddData () {
    $T01().wildcards.Add("X!", "internalcmmdgamaX+1");
    $T01().wildcards.Add("X{A}", "internalcmmdgetlX,A");
    $T01().wildcards.Add("sin[X]", "internalcmmdsineX");
    $T01().wildcards.Add("cos[X]", "internalcmmdcosiX");
    $T01().wildcards.Add("tan[X]", "internalcmmdtangX");
    $T01().wildcards.Add("asin[X]", "internalcmmdasinX");
    $T01().wildcards.Add("acos[X]", "internalcmmdacosX");
    $T01().wildcards.Add("atan[X]", "internalcmmdatanX");
    $T01().wildcards.Add("print[X]", "internalcmmdprntX");
    $T01().wildcards.Add("floor[X]", "internalcmmdflorX");
    $T01().wildcards.Add("ceiling[X]", "internalcmmdceilX");
    $T01().wildcards.Add("map[F,L]", "internalcmmdmapfF,L");
    $T01().wildcards.Add("filter[F,L]", "internalcmmdfiltF,L");
    $T01().wildcards.Add("round[X]", "floor{X+.5}");
    $T01().wildcards.Add("max[A,B]", "_if_A>B_then_A_else_B");
    $T01().wildcards.Add("min[A,B]", "_if_A<B_then_A_else_B");
    $T01().wildcards.Add("abs[X]", "_if_X<0_then_-(X)_else_X");
    $T01().wildcards.Add("A%B", "internalcmmdmoduA,B");
    $T01().wildcards.Add("ln[X]", "internalcmmdnlogX,e");
    $T01().wildcards.Add("log[X]", "internalcmmdnlogX,10");
    $T01().wildcards.Add("log[X,Y]", "internalcmmdnlogX,Y");
    $T01().wildcards.Add("sign[X]", "_if_X=0_then_0_else__if_X>0_then_1_else_-1");
    $T01().wildcards.Add("sqrt[X]", "X^0.5");
    $T01().wildcards.Add("cbrt[X]", "X^(1/3)");
    $T01().wildcards.Add("nrt[X,N]", "X^(1/N)");
    $T01().wildcards.Add("truncate[X]", "internalcmmdtrunX");
    $T01().wildcards.Add(".X", "0.X");
    $T01().wildcards.Add("-.X", "-0.X");
    $T01().wildcards.Add("--X", "X");
    $T01().wildcards.Add("X*0", "0");
    $T01().wildcards.Add("0*X", "0");
    $T01().wildcards.Add("X*1", "X");
    $T01().wildcards.Add("1*X", "X");
    $T01().wildcards.Add("0+X", "X");
    $T01().wildcards.Add("X+0", "X");
    $T01().wildcards.Add("0`X", "-X");
    $T01().wildcards.Add("X/1", "X");
    $T01().wildcards.Add("0/X", "0");
    $T01().wildcards.Add("reciprocal[X]", "1/X");
    $T01().vars.Add("pi", $S00().CallStatic($T02(), "ToString", null, 3.1415926535897931));
    $T01().vars.Add("e", $S00().CallStatic($T02(), "ToString", null, 2.7182818284590451));
    $T01().vars.Add("\u221e", "infinity");
  };

  function MainLoop_AddNecData () {
    $T01().wildcards.Add("X!", "internalcmmdgamaX+1");
    $T01().wildcards.Add("X{A}", "internalcmmdgetlX,A");
    $T01().wildcards.Add("A%B", "internalcmmdmoduA,B");
    $T01().wildcards.Add(".X", "0.X");
    $T01().wildcards.Add("-.X", "-0.X");
    $T01().wildcards.Add("--X", "X");
    $T01().wildcards.Add("X*0", "0");
    $T01().wildcards.Add("0*X", "0");
    $T01().wildcards.Add("X*1", "X");
    $T01().wildcards.Add("1*X", "X");
    $T01().wildcards.Add("0+X", "X");
    $T01().wildcards.Add("X+0", "X");
    $T01().wildcards.Add("0`X", "-X");
    $T01().wildcards.Add("X/1", "X");
    $T01().wildcards.Add("0/X", "0");
    $T01().vars.Add("pi", $S00().CallStatic($T02(), "ToString", null, 3.1415926535897931));
    $T01().vars.Add("e", $S00().CallStatic($T02(), "ToString", null, 2.7182818284590451));
    $T01().vars.Add("\u221e", "infinity");
  };

  function MainLoop_Main (args, $exception) {
    if ((args.length | 0) !== 0) {
      $thisType.AddNecData();
      var inp = $T07().ReadAllText(args[0]);
      var lines = $S01().Construct();
      var temp = "";

      for (var i = 0; i < (inp.length | 0); i = ((i + 1) | 0)) {
        try {
          if (inp.substr(i, 2) == $T09().get_NewLine()) {
            i = ((i + 1) | 0);
          } else if (((inp[i]).charCodeAt(0) | 0) === ((";").charCodeAt(0) | 0)) {
            lines.Add(temp);
            temp = "";
          } else {
            temp = (JSIL.ConcatString(temp, inp[i]));
          }
        } catch ($exception) {
        }
      }
      lines.Add(temp);

      for (var j = 0; j < (lines.get_Count() | 0); j = ((j + 1) | 0)) {
        lines.set_Item(j, $T01().Preprocessor($S02().CallVirtual("get_Item", null, lines, j)));
        $T01().EffPrep($S02().CallVirtual("get_Item", null, lines, j));
      }

      for (var k = 0; k < (lines.get_Count() | 0); k = ((k + 1) | 0)) {
        if (!$T01().RunCommands($S02().CallVirtual("get_Item", null, lines, k))) {
          $T01().ParseMath($S02().CallVirtual("get_Item", null, lines, k));
        }
      }
      $T0B().WriteLine("\nProgram completed, press any key to exit.");
      $T0B().ReadKey();
      return;
    }
    $thisType.AddData();
    $T0B().Write("Build 1.3, H# Interactive: http://iamapersson.github.io/hsharp/ \nPhil Lane Creations\n");

    while (true) {
      $T0B().Write("HSCi> ");
      var inp2 = $T01().Preprocessor($T0B().ReadLine());
      if (!$T01().RunCommands(inp2)) {
        $T0B().WriteLine($T01().ParseMath(inp2));
      }
    }
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "HSCi.MainLoop", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      MainLoop__ctor
    );

    $.Method({Static:true , Public:false}, "AddData", 
      JSIL.MethodSignature.Void, 
      MainLoop_AddData
    );

    $.Method({Static:true , Public:false}, "AddNecData", 
      JSIL.MethodSignature.Void, 
      MainLoop_AddNecData
    );

    $.Method({Static:true , Public:false}, "Main", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.String])), 
      MainLoop_Main
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();
  </body>
</html>
